/* CAPL Script: BCM DTC Read/Clear in CANoe Test System
 * - Reads DTCs via 0x19 02 FF (report by status mask).
 * - Clears DTCs via 0x14 FF FF FF (all groups).
 * - Configurable: Use sysvars for IDs; import ODX for dynamic service defs.
 * - Trigger: Press 'r' to read, 'c' to clear.
 * - Handles timeouts and logs to Write window/Test Report.
 * - Extend to other ECUs: Set sysvar::TargetECU and update IDs via ODX.
 */

includes
{
  // @include "diagDefs.cin"  // Optional external for common diag funcs
}

variables
{
  msTimer tDiagTimeout;      // Response timeout (adjust per ODX P2)
  dword physReqID = 0x681;   // From ODX: Tester -> BCM
  dword physRespID = 0x601;  // From ODX: BCM -> Tester
  char targetECU[32] = "BCM"; // Sysvar configurable for other ECUs
  
  // Sysvars for configurability (set in CANoe panel or ODX import)
  sysvar dword::ReqID;       // e.g., sysSet(ReqID, 0x681);
  sysvar dword::RespID;
}

on sysvar_update ReqID
{
  physReqID = sysGet(ReqID);  // Update from ODX/panel
}

on sysvar_update RespID
{
  physRespID = sysGet(RespID);
}

on start
{
  // Initialize sysvars from ODX if imported
  sysSet(ReqID, 0x681);
  sysSet(RespID, 0x601);
  write("DTC Script Ready for %s. Press 'r' to read, 'c' to clear.", targetECU);
}

on key 'r'  // Trigger DTC read
{
  sendReadDTC();
}

on key 'c'  // Trigger DTC clear
{
  sendClearDTC();
}

void sendReadDTC()
{
  message * req;
  req.id = physReqID;
  req.dlc = 3;
  req.byte(0) = 0x19;  // SID: ReadDTCInformation
  req.byte(1) = 0x02;  // Sub: reportDTCByStatusMask
  req.byte(2) = 0xFF;  // Mask: All status
  output(req);         // Or diagSendRequest if ODX defines BCM.ReadDTCByStatus
  setTimer(tDiagTimeout, 5000);
  write("Sent Read DTC request to %s", targetECU);
  testStepRunning("Reading DTCs");
}

void sendClearDTC()
{
  message * req;
  req.id = physReqID;
  req.dlc = 4;
  req.byte(0) = 0x14;  // SID: ClearDiagnosticInformation
  req.byte(1) = 0xFF;
  req.byte(2) = 0xFF;
  req.byte(3) = 0xFF;  // Group: All DTCs
  output(req);
  setTimer(tDiagTimeout, 5000);
  write("Sent Clear DTC request to %s", targetECU);
  testStepRunning("Clearing DTCs");
}

on message physRespID  // Raw response handler (or on diagResponse BCM.* if ODX)
{
  cancelTimer(tDiagTimeout);
  if (this.byte(0) == 0x59) {  // Positive resp to 0x19
    // Parse DTCs (e.g., from ODX DTC-List sheet)
    int numDTCs = this.byte(2);  // DTC count
    write("DTCs Read: %d found", numDTCs);
    int i;
    for (i = 0; i < numDTCs; i++) {
      dword dtc = (this.byte(3 + i*3) << 16) | (this.byte(4 + i*3) << 8) | this.byte(5 + i*3);
      write("DTC: 0x%X", dtc);
    }
    if (numDTCs == 0) testStepPass("No DTCs");
    else testStepFail("DTCs present");
  } else if (this.byte(0) == 0x54) {  // Positive resp to 0x14
    write("DTCs Cleared Successfully");
    testStepPass("DTC Clear");
  } else if (this.byte(0) == 0x7F) {  // NRC
    write("NRC: 0x%X for SID 0x%X", this.byte(2), this.byte(1));
    testStepFail("Diag Error");
  }
}

on timer tDiagTimeout
{
  write("Diag Timeout for %s", targetECU);
  testStepFail("Timeout");
}

// For ODX Configurability:
// - Import ODX to auto-define diagRequest BCM.ReadDTCByStatusMask { ... }
// - Example: diagRequest BCM.ReadDTCByStatusMask readReq;
//   readReq.statusMask = 0xFF;
//   diagSendRequest(readReq);
// - Switch ECU: on sysvar_update TargetECU { snprintf(targetECU, 32, "%s", sysGet(TargetECU)); }
// - DTC Validation: Compare against extracted DTC list from ODX Excel (hardcode or load via fileRead).

/* Extension for Other ECUs:
// Add if-else in send functions based on targetECU.
// e.g., if (strcmp(targetECU, "VCU") == 0) { physReqID = 0xXXX; } // From new ODX
*/