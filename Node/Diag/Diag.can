/*@!Encoding:1252*/
includes
{
  
}

variables
{
  // === TIMER VÀ MESSAGE OBJECTS ===
  msTimer Timer_delay;                // Timer delay (chua s? d?ng)
  msTimer Timer_BCM;                  // Timer BCM (chua s? d?ng)
  Message 0x681 msg_tx;               // Message g?i di (Tester -> ECU)
  Message 0x601 msg_rx;               // Message nh?n v? (ECU -> Tester)
  
  // === ISO-TP STATE MANAGEMENT ===
  byte udsPayload[512];               // Buffer ch?a toàn b? payload UDS dã ghép
  int totalLen = 0;                   // T?ng d? dài payload UDS (t? First Frame)
  int wroteLen = 0;                   // S? byte dã ghép du?c vào buffer
  int nextSN   = 1;                   // Sequence number CF k? v?ng ti?p theo (1..15, r?i 0)
  
  // === BI?N LOCAL CHO X? LÝ MESSAGE ===
  int i;                              // Bi?n d?m vòng l?p
  int firstChunk;                     // S? byte chép t? First Frame (t?i da 6)
  int remaining;                      // S? byte còn l?i c?n nh?n
  int chunk;                          // S? byte s? chép t? Consecutive Frame hi?n t?i
  int vinLen;                         // Ð? dài VIN sau khi parse
  char vin[64];                       // Buffer ch?a chu?i VIN (ASCII)
  byte sn;                            // Sequence number t? Consecutive Frame
  int L;                              // Ð? dài payload t? Single Frame
  
  timer tMsgTimeout;          // Timer for message timeout
  msTimer tPeriodicCheck;     // Optional periodic check
  const float MESSAGE_TIMEOUT = 500;  // 500 ms timeout
  const int EXPECTED_MSG_ID = 0x123;
}

on start{}

on timer Timer_delay{}

on timer Timer_BCM{}
on key 'a'
{
  // === H?Y TIMER BCM ===
  cancelTimer(Timer_BCM);
}

on key 'd'
{
  // === G?I REQUEST Ð?C VIN ===
  msg_tx.dlc = 8;                    // Ð?t DLC = 8 byte (CAN Classic yêu c?u padding)
  msg_tx.byte(0) = 0x03;             // SF (Single Frame): PCI = 0x0L, L=3 (3 byte UDS payload)
  msg_tx.byte(1) = 0x22;             // SID: ReadDataByIdentifier (0x22)
  msg_tx.byte(2) = 0xF1;             // DID High: 0xF1
  msg_tx.byte(3) = 0x90;             // DID Low: 0x90 => DID = 0xF190 (VIN)
  msg_tx.byte(4) = 0x00;             // Padding byte 4
  msg_tx.byte(5) = 0x00;             // Padding byte 5
  msg_tx.byte(6) = 0x00;             // Padding byte 6
  msg_tx.byte(7) = 0x00;             // Padding byte 7
  output(msg_tx);                    // G?i request trên CAN ID 0x681

  // === RESET TR?NG THÁI ISO-TP CHO RESPONSE M?I ===
  totalLen = 0;                      // T?ng d? dài payload UDS (t? FF)
  wroteLen = 0;                      // S? byte dã ghép du?c
  nextSN   = 1;                      // Sequence number CF k? v?ng ti?p theo (1..15)
}

on message 0x123
{
  // Message received ? reset timer
  cancelTimer(tMsgTimeout);         // Cancel if running
  setTimer(tMsgTimeout, MESSAGE_TIMEOUT);
  // Optional: update signal values or counters
  write("Message 0x123 received at %time");
}

on message 0x601
{
  msg_rx = this;
  
  // === LOG RESPONSE Ð? DEBUG (HEX FORMAT) ===
  write("RX 0x601: %02X %02X %02X %02X %02X %02X %02X %02X",
        msg_rx.byte(0), msg_rx.byte(1), msg_rx.byte(2), msg_rx.byte(3),
        msg_rx.byte(4), msg_rx.byte(5), msg_rx.byte(6), msg_rx.byte(7));

  // === X? LÝ FIRST FRAME (FF) - 0x10 ===
  if ((msg_rx.byte(0) & 0xF0) == 0x10)
  {
    // Tính t?ng d? dài payload UDS t? 12-bit length trong FF
    totalLen = ((msg_rx.byte(0) & 0x0F) << 8) | msg_rx.byte(1);
    
    // Chép t?i da 6 byte payload d?u t? FF (byte 2-7)
    firstChunk = totalLen;
    if (firstChunk > 6) firstChunk = 6;
    
    for (i = 0; i < firstChunk; i++) 
    {
      udsPayload[i] = msg_rx.byte(2 + i);  // Chép t? byte(2) c?a FF
    }
    wroteLen = firstChunk;

    // === G?I FLOW CONTROL (FC) - Clear To Send ===
    msg_tx.dlc = 8;                    // DLC = 8 byte
    msg_tx.byte(0) = 0x30;             // FC: Clear To Send
    msg_tx.byte(1) = 0x00;             // BlockSize = 0 (không gi?i h?n)
    msg_tx.byte(2) = 0x00;             // STmin = 0ms (th?i gian t?i thi?u gi?a các CF)
    msg_tx.byte(3) = 0x00;             // Padding
    msg_tx.byte(4) = 0x00;             // Padding
    msg_tx.byte(5) = 0x00;             // Padding
    msg_tx.byte(6) = 0x00;             // Padding
    msg_tx.byte(7) = 0x00;             // Padding
    output(msg_tx);                    // G?i FC trên CAN ID 0x681
    nextSN = 1;                        // Reset sequence number CF v? 1
  }
  // === X? LÝ CONSECUTIVE FRAME (CF) - 0x2N ===
  else if ((msg_rx.byte(0) & 0xF0) == 0x20)
  {
    // L?y sequence number t? 4 bit th?p c?a byte d?u CF
    sn = msg_rx.byte(0) & 0x0F;
    
    // Ki?m tra sequence number có dúng th? t? không
    if (sn != (nextSN & 0x0F)) 
    {
      write("CF SN mismatch: got %d exp %d", sn, nextSN & 0x0F);
      return;
    }
    
    // Tính s? byte còn l?i c?n nh?n và s? byte s? chép t? CF này
    remaining = totalLen - wroteLen;
    chunk = remaining;
    if (chunk > 7) chunk = 7;  // CF ch? ch?a t?i da 7 byte payload
    
    // Chép payload t? CF (b?t d?u t? byte(1), b? qua PCI byte(0))
    for (i = 0; i < chunk; i++) 
    {
      udsPayload[wroteLen + i] = msg_rx.byte(1 + i);
    }
    wroteLen += chunk;
    
    // C?p nh?t sequence number cho CF ti?p theo (1..15, r?i 0)
    nextSN++;
    if (nextSN > 15) nextSN = 0;

    // === KI?M TRA ÐÃ NH?N Ð? PAYLOAD CHUA ===
    if (wroteLen >= totalLen && totalLen >= 3)
    {
      // Ki?m tra header UDS: 0x62 (positive response) + 0xF190 (DID)
      if (udsPayload[0] == 0x62 && udsPayload[1] == 0xF1 && udsPayload[2] == 0x90)
      {
        // Tính d? dài VIN (b? 3 byte header UDS)
        vinLen = totalLen - 3; 
        if (vinLen > 31) vinLen = 31;  // Gi?i h?n d? dài VIN
        
        // Chuy?n d?i t? hex bytes sang ASCII string
        for (i = 0; i < vinLen; i++) 
        {
          vin[i] = udsPayload[3 + i];  // B? qua 3 byte header, chép VIN
        }
        vin[vinLen] = 0;  // Null terminate string
        
        // === IN K?T QU? VIN ===
        write("VIN: %s", vin);
        write("VIN exported: %s", vin);
      }
    }
  }
  // === X? LÝ SINGLE FRAME (SF) - 0x0L (TRU?NG H?P Ð?C BI?T) ===
  else if ((msg_rx.byte(0) & 0xF0) == 0x00)
  {
    // L?y d? dài payload t? 4 bit th?p c?a PCI
    L = msg_rx.byte(0) & 0x0F; 
    if (L > 7) L = 7;  // Gi?i h?n t?i da 7 byte payload trong SF
    
    // Chép toàn b? payload t? SF (b?t d?u t? byte(1))
    for (i = 0; i < L; i++) 
    {
      udsPayload[i] = msg_rx.byte(1 + i);
    }
    totalLen = L;      // T?ng d? dài = d? dài SF
    wroteLen = L;      // Ðã nh?n d?
  }
}