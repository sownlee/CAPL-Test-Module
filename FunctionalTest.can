/*@!Encoding:1252*/
includes
{

}

variables
{
const dword kWAIT_TIMEOUT = 500; // 500msecs 
int WaitResult;
}

void MainTest() 
{ 
//cf_testPreparation();
//ctc_RequestLock();
ctc_TimeoutSignal();
} 
void cf_testPreparation() 
{ 
/* Add Description of Test Module */ 
TestModuleDescription("Sample test cases written in CAPL."); 
/* Add Information into Test engineer Information Table */ 
TestReportAddEngineerInfo("Company", "VinFast.Ltd."); 
TestReportAddEngineerInfo("Tester name", "Le Dinh Giang Son"); 
TestReportAddSetupInfo("CANoe", "Version 15.0"); 
TestReportAddSetupInfo("vTestStudio", "Version 5.0"); 
TestReportAddSUTInfo ("SUT", "Doors ECU"); 
} 
testfunction PreConditions() 
{ 
    testStep("Pre-cond","Start"); 
    testStep("","Set Ignition to ON"); 
    // Set Ignition to ON 
    @sysvar::testNS::IgnitionStart = @sysvar::testNS::IgnitionStart::Ign_ON; 
    testWaitForTimeout(500); 
    testStep("Pre-cond","End"); 
}

testfunction PostConditions() 
{ 
    testStep("Post-cond","Start"); 
    testStep("","Set Ignition to OFF"); 
    // Set Ignition to OFF 
    @sysvar::testNS::IgnitionStart = @sysvar::testNS::IgnitionStart::Ign_OFF; 
    testWaitForTimeout(500); 
    testStep("Post-cond","End"); 
}
testcase ctc_TimeoutSignal()
{
  int waitRes;

  TestCaseTitle("Timeout Test", "Verify BCM_FrontLeftDoorAjarStatus times out (no signal extraction)");

  PreConditions();

  testStep("Step 1", "Waiting for message BCM_FrontLeftDoorAjarStatus for %d ms", kWAIT_TIMEOUT);

  waitRes = TestWaitForMessage(GW_BCM_DoorState_0x4D4, kWAIT_TIMEOUT);
//PT::VCU::GW_BCM_DoorState_0x4D4::BCM_FrontLeftDoorAjarStatus
  switch(waitRes)
  {
    case 0:
      // No message received within timeout -> expected for this timeout-check test
      TestStepPass("Timeout", "Message BCM_FrontLeftDoorAjarStatus not received within %d ms", kWAIT_TIMEOUT);
      break;

    case 1:
      // Message was received � test expects a timeout, so fail.
      // We intentionally DO NOT call TestGetWaitEventMsgData here (no signal variable).
      TestStepFail("Received", "Message BCM_FrontLeftDoorAjarStatus was received before timeout");
      break;

    default:
      TestStepFail("Error", "TestWaitForMessage returned unexpected value %d", waitRes);
  }

  PostConditions();
}

testcase ctc_WindowDownUp() 
{ 
int LoopVar; 
message BCM_Status_0x201 WinStat; 
//BCM_Status_0x201::BCM_FLWIN_Postion_Reserved
TestCaseTitle("Rolling Windows", "Window Down and Up"); 
PreConditions(); 
testStep("Test Step 1", "Rolling down window completely"); 
 // For loop to roll down the window completely 
  for(LoopVar = 1; LoopVar < 16; LoopVar++) 
  { 
    testStep("Start","Roll Down Window to position %d",LoopVar); 
    //Set Window Request to Roll Down 
    @sysvar::Main::WindowRequest = @sysvar::Main::WindowRequest::Roll_Down; 
    // Wait for the message “WindowState” to occur 
    WaitResult = TestWaitForMessage(GW_BCM_Status_0x201, kWAIT_TIMEOUT); 
    // Determine results of test step 
    switch(WaitResult) 
    { 
      case 0: TestStepFail("Message not received"); 
        break; 
      case 1: 
        // Retrieve the message data of “WinStat” 
        TestGetWaitEventMsgData(WinStat); 
        // Check if Actual Window position = Calculated Window position 
        if(WinStat.BCM_FLWIN_Postion_Reserved == LoopVar) 
          TestStepPass("","Window is rolled down to position %d", 
WinStat.BCM_FLWIN_Postion_Reserved); 
        else 
          TestStepFail("","Window is still in position %d", 
WinStat.BCM_FLWIN_Postion_Reserved); 
        break; 
      default:  
          TestStepFail("Failed for other reasons"); 
    } 
    // Make sure to reset Window Down button to original position 
    @sysvar::Main::WindowRequest = @sysvar::Main::WindowRequest::No_Request; 
  } 
  TestReportAddWindowCapture("Trace", "" , "Window Down"); 
  traceWindowClear("Trace"); 
  testWaitForTimeout(kWAIT_TIMEOUT); 
   
  testStep("Test Step 2", "Rolling up window completely"); 
  // For loop to roll up the window completely 
  for(LoopVar = 14; LoopVar >= 0; LoopVar--) 
  { 
    testStep("Start","Roll Up Window to position %d",LoopVar); 
    //Set Window Request to Roll Up 
    @sysvar::Main::WindowRequest = @sysvar::Main::WindowRequest::Roll_Up; 
    // Wait for the message “WindowState” to occur 
    WaitResult = TestWaitForMessage(BCM_Status_0x201, kWAIT_TIMEOUT); 
    // Determine results of test step 
    switch(WaitResult) 
    { 
      case 0: TestStepFail("Message not received"); 
        break; 
      case 1: 
        // Retrieve the message data of “WinStat” 
        TestGetWaitEventMsgData(WinStat); 
        // Check if Actual Window position = Calculated Window position 
        if(WinStat.BCM_FLWIN_Postion_Reserved == LoopVar) 
          TestStepPass("","Window is rolled up to position %d", WinStat.BCM_FLWIN_Postion_Reserved); 
        else
        TestStepFail("","Window is still in position %d", WinStat.BCM_FLWIN_Postion_Reserved); 
        break; 
      default:  
          TestStepFail("Failed for other reasons"); 
    } 
    // Make sure to reset Window Down button to original position 
    @sysvar::Main::WindowRequest = @sysvar::Main::WindowRequest::No_Request; 
  } 
  TestReportAddWindowCapture("Trace", "" , "Window Up"); 
   
  PostConditions(); 
} 

testcase ctc_RequestLock() 
{ 
  message GW_BCM_DoorState_0x4D4 LockingStatus; 
  
  TestCaseTitle("Locking Test", "Request to Lock"); 
   
  PreConditions(); 
   
  testStep("","Set request to Lock State"); 
  @sysvar::testNS::LockRq = @sysvar::testNS::LockRq::RqToLock; 
   
  TestStep("Unlocking Test", "Set Locking request to RqToUnlock"); 
  @sysvar::testNS::LockRq = @sysvar::testNS::LockRq::RqToUnlock; 
   
  // Wait for the reply message from Doors ECU for 500ms 
  WaitResult = TestWaitForMessage(BCM_FrontLeftDoorAjarStatus, kWAIT_TIMEOUT); 
   
  // Determine results of test step 
  switch(WaitResult) 
  { 
    case 0: TestStepFail("Message not received"); 
      break; 
    case 1: 
      // Retrieve the message data of “LockSysState” 
      TestGetWaitEventMsgData(LockingStatus); 
      // If Lock state is unlocked, then test passed. 
      if(LockingStatus.STAT_DoorLockDriver == STAT_DoorLockDriver::Unlocked ) 
        TestStepPass("Test Step 1", "Door is Unlocked"); 
      else 
        TestStepFail("Test Step 1", "Still Locked"); 
      break; 
  } 
  TestWaitForTimeout(kWAIT_TIMEOUT); // Wait for 500ms 
   
  TestStep("Locking Test", "Set Locking request to RqToLock"); 
  @sysvar::testNS::LockRq = @sysvar::testNS::LockRq::RqToLock; 
   
  // Wait for the message “LockingSysState” to occur for 500ms 
  WaitResult = TestWaitForMessage(GW_BCM_DoorSts_0x3D0, kWAIT_TIMEOUT); 
  // Determine results of test step 
  switch(WaitResult) 
  { 
    case 0: TestStepFail("Message not received"); 
      break; 
    case 1: 
      // Retrieve the message data of “LockSysState” 
      TestGetWaitEventMsgData(LockingStatus);
      // If Lock state is locked, then test passed. 
      if(LockingStatus.STAT_DoorLockDriver == STAT_DoorLockDriver::Locked ) 
        TestStepPass("Test Step 1", "Door is Locked"); 
      else 
        TestStepFail("Test Step 1", "Still Unlocked"); 
      break; 
  } 
  TestWaitForTimeout(kWAIT_TIMEOUT); // Wait for 500ms 
   
  PostConditions(); 
}

testcase ctc_AutoLock() 
{ 
  message EngineStatus EngState; 
  message LockingState LockSysState; 
  byte ind1,ind2; 
   
  TestCaseTitle("Locking Test", "Auto Lock"); 
   
  PreConditions(); 
   
  testStep("","Set Locking request to RqToUnlock"); 
  @sysvar::Main::LockRq = @sysvar::Main::LockRq::RqToUnlock; 
   
  //Check if the door is "Unlocked" before reaching the threshold 
  testStep("Set speed","15 kmph"); 
  @sysvar::Main::Velocity = 15; 
   
  ind1 = testJoinMessageEvent(EngineStatus); 
  ind2 = testJoinMessageEvent(LockingState); 
  testWaitForAllJoinedEvents(200); 
  testGetWaitEventMsgData(ind1, EngState); 
  testGetWaitEventMsgData(ind2, LockSysState); 
   
  if(EngState.Velocity == 15) 
  { 
    testWaitForTimeout(50); 
    if(LockSysState.LockState == VtSig_LockState::Unlocked) 
      testStepPass("Door is in Unlocked state before reaching the speed threshold"); 
    else 
      testStepFail("Door is not in Unlocked state before reaching the speed threshold"); 
  } 
   
  //Check if the door is "Locked" after reaching the threshold 
  testStep("Set speed","16 kmph"); 
  @sysvar::Main::Velocity = 16; 
   
  ind1 = testJoinMessageEvent(EngineStatus); 
  ind2 = testJoinMessageEvent(LockingState); 
  testWaitForAllJoinedEvents(200); 
  testGetWaitEventMsgData(ind1, EngState); 
  testGetWaitEventMsgData(ind2, LockSysState); 
   
  if(EngState.Velocity == 16) 
  { 
    testWaitForMessage(LockingState,200); 
    if(LockSysState.LockState == VtSig_LockState::Locked) 
      testStepPass("Door is in Locked state after reaching the speed threshold");
else 
    testStepFail("Door is not in Locked state after reaching the speed threshold"); 
}     
testStep("","Reset speed back to 0 kmph"); 
@sysvar::Main::Velocity = 0; 
PostConditions(); 
} 
