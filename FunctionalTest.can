/*@!Encoding:1252*/
includes
{

}

variables
{
const dword kWAIT_TIMEOUT = 500; // 500msecs 
int WaitResult;
}

void MainTest() 
{ 
cf_testPreparation();
ctc_RequestLock();
ctc_WindowDownUp();  
ctc_TimeoutSignal();
} 
void cf_testPreparation() 
{ 
/* Add Description of Test Module */ 
TestModuleDescription("Sample test cases written in CAPL."); 
/* Add Information into Test engineer Information Table */ 
TestReportAddEngineerInfo("Company", "VinFast.Ltd."); 
TestReportAddEngineerInfo("Tester name", "Le Dinh Giang Son"); 
TestReportAddSetupInfo("CANoe", "Version 15.0"); 
TestReportAddSetupInfo("vTestStudio", "Version 5.0"); 
TestReportAddSUTInfo ("SUT", "Doors ECU"); 
} 
testfunction PreConditions() //Ignition ON + m? c?a + các di?u ki?n c?n
{ 
    testStep("Pre-cond","Start"); 
    testStep("","Set Ignition to ON"); 
    // Set Ignition to ON 
    @sysvar::testNS::IgnitionStart = @sysvar::testNS::IgnitionStart::Ign_ON; 
    testWaitForTimeout(500); 
    testStep("Pre-cond","End"); 
}

testfunction PostConditions() //Ignition OFF + reset t?t c? v? tr?ng thái an toàn
{ 
    testStep("Post-cond","Start"); 
    testStep("","Set Ignition to OFF"); 
    // Set Ignition to OFF 
    @sysvar::testNS::IgnitionStart = @sysvar::testNS::IgnitionStart::Ign_OFF; 
    testWaitForTimeout(500); 
    testStep("Post-cond","End"); 
}
testcase ctc_TimeoutSignal()
{
  int waitRes;

  TestCaseTitle("Timeout Test", "Verify BCM_FrontLeftDoorAjarStatus times out (no signal extraction)");

  PreConditions();

  testStep("Step 1", "Waiting for message BCM_FrontLeftDoorAjarStatus for %d ms", kWAIT_TIMEOUT);

  waitRes = TestWaitForMessage(GW_BCM_DoorState_0x4D4, kWAIT_TIMEOUT);
//PT::VCU::GW_BCM_DoorState_0x4D4::BCM_FrontLeftDoorAjarStatus
  switch(waitRes)
  {
    case 0:
      // No message received within timeout -> expected for this timeout-check test
      TestStepPass("Timeout", "Message BCM_FrontLeftDoorAjarStatus not received within %d ms", kWAIT_TIMEOUT);
      break;

    case 1:
      // Message was received ï¿½ test expects a timeout, so fail.
      // We intentionally DO NOT call TestGetWaitEventMsgData here (no signal variable).
      TestStepFail("Received", "Message BCM_FrontLeftDoorAjarStatus was received before timeout");
      break;

    default:
      TestStepFail("Error", "TestWaitForMessage returned unexpected value %d", waitRes);
  }

  PostConditions();
}

testcase ctc_WindowDownUp() 
{ 
int LoopVar; 
message BCM_Status_0x201 WinStat; 
//BCM_Status_0x201::BCM_FLWIN_Postion_Reserved
TestCaseTitle("Rolling Windows", "Window Down and Up"); 
PreConditions(); 
testStep("Test Step 1", "Rolling down window completely"); 
 // For loop to roll down the window completely 
  for(LoopVar = 1; LoopVar < 16; LoopVar++) 
  { 
    testStep("Start","Roll Down Window to position %d",LoopVar); 
    //Set Window Request to Roll Down 
    @sysvar::testNS::WindowRequest = @sysvar::testNS::WindowRequest::Roll_Down; 
    // Wait for the message â€œWindowStateâ€ to occur 
    WaitResult = TestWaitForMessage(BCM_Status_0x201, kWAIT_TIMEOUT); 
    // Determine results of test step 
    switch(WaitResult) 
    { 
      case 0: TestStepFail("Message not received"); 
        break; 
      case 1: 
        // Retrieve the message data of  
        TestGetWaitEventMsgData(WinStat); 
        // Check if Actual Window position = Calculated Window position 
        if(WinStat.BCM_FLWIN_Postion_Reserved == LoopVar) 
          TestStepPass("","Window is rolled down to position %d", WinStat.BCM_FLWIN_Postion_Reserved); 
        else 
          TestStepFail("","Window is still in position %d", WinStat.BCM_FLWIN_Postion_Reserved); 
        break; 
      default:  
          TestStepFail("Failed for other reasons"); 
    } 
    // Make sure to reset Window Down button to original position 
    @sysvar::testNS::WindowRequest = @sysvar::testNS::WindowRequest::No_Request; 
  } 
  TestReportAddWindowCapture("Trace", "" , "Window Down"); 
  traceWindowClear("Trace"); 
  testWaitForTimeout(kWAIT_TIMEOUT); 
   
  testStep("Test Step 2", "Rolling up window completely"); 
  // For loop to roll up the window completely 
  for(LoopVar = 14; LoopVar >= 0; LoopVar--) 
  { 
    testStep("Start","Roll Up Window to position %d",LoopVar); 
    //Set Window Request to Roll Up 
    @sysvar::testNS::WindowRequest = @sysvar::testNS::WindowRequest::Roll_Up; 
    // Wait for the message â€œWindowStateâ€ to occur 
    WaitResult = TestWaitForMessage(BCM_Status_0x201, kWAIT_TIMEOUT); 
    // Determine results of test step 
    switch(WaitResult) 
    { 
      case 0: TestStepFail("Message not received"); 
        break; 
      case 1: 
        // Retrieve the message data of â€œWinStatâ€ 
        TestGetWaitEventMsgData(WinStat); 
        // Check if Actual Window position = Calculated Window position 
        if(WinStat.BCM_FLWIN_Postion_Reserved == LoopVar) 
          TestStepPass("","Window is rolled up to position %d", WinStat.BCM_FLWIN_Postion_Reserved); 
        else
        TestStepFail("","Window is still in position %d", WinStat.BCM_FLWIN_Postion_Reserved); 
        break; 
      default:  
          TestStepFail("Failed for other reasons"); 
    } 
    // Make sure to reset Window Down button to original position 
    @sysvar::testNS::WindowRequest = @sysvar::testNS::WindowRequest::No_Request; 
  } 
  TestReportAddWindowCapture("Trace", "" , "Window Up"); 
   
  PostConditions(); 
} 

testcase ctc_RequestLock()
{
  // Khai báo dúng message object
  message BCM_DoorState_0x4D4 doorMsg;

  TestCaseTitle("Locking Test", "Verify Central Lock/Unlock Request");

  PreConditions();

  /* ====================== BU?C 1: G?i l?nh Unlock ====================== */
  testStep("", "Send Unlock Request");
  @sysvar::testNS::LockRq = @sysvar::testNS::LockRq::RqToUnlock;
 
  WaitResult = TestWaitForMessage(BCM_DoorState_0x4D4, kWAIT_TIMEOUT);
  switch(WaitResult)
  {
    case 0:
      TestStepFail("No Response", "Message 0x4D4 not received after Unlock request");
      break;
    case 1:
      TestGetWaitEventMsgData(doorMsg);
      if (doorMsg.BCM_LeftDoorLockStatusDrv == 0)   // 0 = Unlocked
        TestStepPass("Unlock Successful", "Driver door is Unlocked");
      else
        TestStepFail("Unlock Failed", "Driver door still Locked (value = %d)", doorMsg.BCM_LeftDoorLockStatusDrv);
      break;
    default:
      TestStepFail("Error", "Unexpected WaitResult = %d", WaitResult);
  }

  testWaitForTimeout(500);

  /* ====================== BU?C 2: G?i l?nh Lock ====================== */
  testStep("Locking Test", "Send Lock Request");
  @sysvar::testNS::LockRq = @sysvar::testNS::LockRq::RqToLock;
  
  WaitResult = TestWaitForMessage(BCM_DoorState_0x4D4, kWAIT_TIMEOUT);
  switch(WaitResult)
  {
    case 0:
      TestStepFail("No Response", "Message 0x4D4 not received after Lock request");
      break;
    case 1:
      TestGetWaitEventMsgData(doorMsg);
      if (doorMsg.BCM_LeftDoorLockStatusDrv == 1)   // 1 = Locked
        TestStepPass("Lock Successful", "Driver door is Locked");
      else
        TestStepFail("Lock Failed", "Driver door still Unlocked (value = %d)", doorMsg.BCM_LeftDoorLockStatusDrv);
      break;
    default:
      TestStepFail("Error", "Unexpected WaitResult = %d", WaitResult);
  }

  // Reset v? tr?ng thái an toàn (tùy ch?n)
  @sysvar::testNS::LockRq = @sysvar::testNS::LockRq::No_Request;

  PostConditions();
}

testcase ctc_AutoLock()
{
  // Khai báo message d? nh?n d? li?u
  message GW_ABS_Status_0x118       absMsg;
  message GW_BCM_DoorState_0x4D4    doorMsg;

  int indAbs, indDoor;

  TestCaseTitle("Auto Lock Test", "Verify doors auto-lock when vehicle speed exceeds threshold");

  PreConditions();

  // Step 1: Ð?t yêu c?u m? khóa (RqToUnlock)
  testStep("Set lock request", "Set Lock Request to Unlock");
  @sysvar::Main::LockRq = @sysvar::Main::LockRq::RqToUnlock;

  // Step 2: Ð?t t?c d? = 15 km/h ? ki?m tra c?a v?n m? (Unlocked)
  testStep("Set vehicle speed", "Set speed to 15 km/h");
  @sysvar::Main::ABS_VehicleSpeed = 15;

  // Join event d? ch? 2 message du?c g?i di (do thay d?i sysvar s? kích g?i message)
  indAbs  = testJoinMessageEvent(GW_ABS_Status_0x118);
  indDoor = testJoinMessageEvent(GW_BCM_DoorState_0x4D4);
  testWaitForAllJoinedEvents(500);  // Ð?i t?i da 500ms

  // L?y d? li?u message v?a nh?n
  testGetWaitEventMsgData(indAbs,  absMsg);
  testGetWaitEventMsgData(indDoor, doorMsg);

  // Ki?m tra t?c d? và tr?ng thái c?a ? 15 km/h
  if (absMsg.ABS_VehicleSpeed == 15)
  {
    testWaitForTimeout(50);  // Ð?i ?n d?nh m?t chút
    if (doorMsg.BCM_LeftDoorLockStatusDrv == VtSig_LockState::Unlocked)
      testStepPass("Door remains Unlocked at 15 km/h (below threshold)");
    else
      testStepFail("Door is Locked at 15 km/h - should be Unlocked");
  }
  else
  {
    testStepFail("ABS_VehicleSpeed not updated to 15 km/h");
  }

  // Step 3: Tang t?c d? lên 16 km/h ? ki?m tra c?a t? d?ng khóa
  testStep("Set vehicle speed", "Set speed to 16 km/h (exceed threshold)");
  @sysvar::Main::ABS_VehicleSpeed = 16;

  // Join l?i d? ch? message m?i
  indAbs  = testJoinMessageEvent(GW_ABS_Status_0x118);
  indDoor = testJoinMessageEvent(GW_BCM_DoorState_0x4D4);
  testWaitForAllJoinedEvents(500);

  testGetWaitEventMsgData(indAbs,  absMsg);
  testGetWaitEventMsgData(indDoor, doorMsg);

  // Ki?m tra t?c d? và tr?ng thái khóa ? 16 km/h
  if (absMsg.ABS_VehicleSpeed == 16)
  {
    testWaitForTimeout(100);  // Ð?i ECU x? lý và khóa c?a
    if (doorMsg.BCM_LeftDoorLockStatusDrv == VtSig_LockState::Locked)
      testStepPass("Door auto-locked when speed exceeds threshold (16 km/h)");
    else
      testStepFail("Door did NOT auto-lock after speed > threshold");
  }
  else
  {
    testStepFail("ABS_VehicleSpeed not updated to 16 km/h");
  }

  // Step 4: Reset t?c d? v? 0
  testStep("Reset", "Set vehicle speed back to 0 km/h");
  @sysvar::Main::ABS_VehicleSpeed = 0;

  PostConditions();
}